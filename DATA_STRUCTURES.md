# Data Structures Overview

This document describes the key data structures used in the TurtleMessenger backend (Java/Spring Boot) and how they relate to the React/Vite frontend.  
For brevity, only the persistent JPA entities and the main DTOs/records that travel over the REST API are covered.

---

## 1. Persistent Domain Models (JPA entities)

| Entity | Purpose | Key Fields | Notes |
|--------|---------|------------|-------|
| **UserAccount** | Represents a registered user. | `id` (Long, PK, auto-generated)  
`username` (String, unique, 3-50 chars, lowercase)  
`passwordHash` (String, BCrypt)  
`createdAt` (Instant) | • Enforced unique constraint on `username`.  
• Password hash is created by `AuthService` using `PasswordEncoder`. |
| **ChatRoom** | A logical chat channel (e.g. room #1). | `id` (Long, _assigned_ not generated)  
`name` (String)  
`createdAt` (Instant) | Room IDs are predefined so that REST /ws endpoints can map directly to the numeric room. |
| **Message** | Stores every chat message. | `id` (Long)  
`room` (Many-to-One → `ChatRoom`)  
`senderUser` (Many-to-One → `UserAccount`, nullable for system messages)  
`senderUsername` (String snapshot)  
`content` (String, up to 2000 chars)  
`createdAt` (Instant) | • Has DB index on `(room_id, created_at)` for fast pagination.  
• Includes legacy `contentLegacy` column for backward-compat.  
• `@PrePersist/@PreUpdate` sync the legacy column. |
| **ContactRelation** | Directed edge in the contact graph (`user` ➜ `contact`). | `id` (Long)  
`user` (Many-to-One → `UserAccount`) – _owner of the contact list_  
`contact` (Many-to-One → `UserAccount`) – _other person_  
`status` (`ContactStatus` enum)  
`createdAt` (Instant) | • Unique pair constraint: `(user_id, contact_id)` so no duplicates.  
• Only **one** row is created for a pending request (no mirror).  
• On acceptance, a mirrored row is added/updated. |
| **ContactStatus** | Enum for the relation state. | Values: `PENDING`, `ACCEPTED`, `BLOCKED` | Used by `ContactRelation` and exposed in API DTOs. |

---

## 2. Data-Transfer Objects (DTOs) / REST Records

These are **plain objects/records** returned or accepted by the REST API—kept minimal so the frontend only receives what it needs.

| DTO / Record | Direction | Shape | Endpoint(s) |
|--------------|-----------|-------|-------------|
| **ContactDTO** | Response | `{ id: Long, username: String, status: String }` | • `GET /api/contacts`  
• `GET /api/contacts/requests`  
• Returned by `POST /api/contacts` & `/api/contacts/accept`. |
| **AddContactRequest** | Request | `{ user: String }` where the value can be **username** _or_ **numeric id**. | `POST /api/contacts` |
| **LoginRequest** | Request | `{ username: String, password: String }` | `POST /api/auth/login` |
| **RegisterRequest** | Request | `{ username: String, password: String }` | `POST /api/auth/register` |
| **RefreshTokenRequest** (body variant) | Request | `{ refreshToken: String }` | `POST /api/auth/refresh` (token can also come from `Authorization: Bearer ...` header) |
| **ChatMessagePayload** | Request & STOMP | `{ roomId: Long, senderId: String, content: String, ts: long }` | • WebSocket `/app/rooms.{id}.send`  
• REST `POST /api/rooms/{roomId}/messages` |

---

## 3. JWT Tokens

Although not JPA entities, **access** and **refresh** tokens are fundamental data structures:

| Token | TTL | Location | Generated by |
|-------|-----|----------|--------------|
| **Access token** | default 900 s (15 min) | `Authorization: Bearer` header (both REST & WebSocket) | `JwtUtil` inside `AuthController#/login` or `/register` |
| **Refresh token** | default 7 days | Stored in browser `localStorage` and sent either in request body or `Authorization` header to `/api/auth/refresh`. | Same as above |

`JwtUtil` stores claims `{ sub, iat, exp }` and signs with **HS256** using a secret read from `TM_JWT_SECRET` (or `dev-secret-change-me` in dev).

---

## 4. Relationships diagram (text-only)

```text
UserAccount (1) <--- user --- ContactRelation --- contact ---> (1) UserAccount
    |                                      |
    | (optional)                           | (many)
    +----< Message >---- ChatRoom          +----< Message >---- ChatRoom
```

- A `UserAccount` can own many `ContactRelation` rows (directed edges) and many `Message` rows.
- Each `Message` belongs to exactly **one** `ChatRoom`.
- A `ChatRoom` can have many `Message` rows but is otherwise independent from contacts.

---

## 5. Validation & Invariants

| Structure | Invariant / Validation rule |
|-----------|-----------------------------|
| `UserAccount.username` | Lower-case, 3-50 chars, regex `[a-z0-9._-]+`, unique. |
| `UserAccount.passwordHash` | BCrypt (created by `PasswordEncoder`). |
| `ContactRelation` | Unique `(user, contact)` pair.  
`user != contact` (enforced in service layer). |
| `ContactService.addContact` | • Rejects self-add  
• Auto-accepts if inverse pending row exists. |

---

Last updated: {{DATE}}
